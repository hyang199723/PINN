mse = mean((yhat - test$y)^2)
mse = mean((yhat - test[,3])^2)
mse
plot(x = test[, 3], y = yhat)
plot(x = test_loc[, 1], y = test_loc[, 2], pch = 19, col = test[,3] + 2)
#################################################################
#################################################################
#################################################################
#################################################################
# Generate data from GpGp and try GpGp
#locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
N = 1000
length <- 1
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(1, 0.2, 1, 0.01), "matern_isotropic",  locs, 100)
var(y)
# Matern isotropic variance, range, smoothness, nugget
# The nugget value σ2τ2 is added to the diagonal of the covariance matrix.
# NOTE: the nugget is σ2τ2, not τ2.
fit <- fit_model(y, locs, rep(1, N), "matern_isotropic")
fit$covparms
size = 1000
full = full_3D[1:size,,1]
# Visualize the data
df <- data.frame(long=full[,1],lat=full[,2],Y=full[,3])
ggplot(df, aes(long, lat)) +
geom_point(aes(colour = Y)) +
scale_colour_gradientn(colours = viridis(10))
ggplot(df, aes(long, lat)) +
geom_point(aes(colour = Y)) +
scale_colour_gradientn(colours = viridis(10))
# Train test split
train_row = sample(1:size, size * 0.8)
train = full[train_row, ]
test = full[-train_row, ]
rownames(train) = NULL
rownames(test) = NULL
train_loc = as.matrix(train[, 1:2])
test_loc = as.matrix(test[, 1:2])
fit <- fit_model(train[,3], train_loc, rep(1, size * 0.8), "matern_isotropic",  m_seq = c(10, 30))
# covparams: variance, range, smoothness, nugget
params = fit$covparms
vvv = params[1]
range = params[2]
smooth = params[3]
nugget = params[4]
vvv
params
test_x = rep(1, size * 0.2)
yhat = predictions(fit, test_loc, test_x)
mse = mean((yhat - test[,3])^2)
mse
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
locs
locs
#################################################################
#################################################################
#################################################################
#################################################################
# Generate data from GpGp and try GpGp
#locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
iters = 100
N = 2000
gpgp_data = array(0, dim = c(N * 3, iters))
length <- 1
for (i in 1:iters) {
slice = rep(0, N*3)
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(1, 0.2, 1, 0.01), "matern_isotropic",  locs, 100)
lon = locs[,1]
lat = locs[,2]
slice[seq(1, length(slice), by = 3)] = lon
slice[seq(2, length(slice), by = 3)] = lat
slice[seq(3, length(slice), by = 3)] = y
gpgp_data[, i] = slice
}
full = cbind(lon, lat, y)
df <- data.frame(long=full[,1],lat=full[,2],Y=full[,3])
ggplot(df, aes(long, lat)) +
geom_point(aes(colour = Y)) +
scale_colour_gradientn(colours = viridis(10))
var(y)
dim(gpgp_data)
View(gpgp_data)
?write.csv
write.csv(gpgp_data, "Data/gpgp_02_1_1.csv", row.names = F, col.names = F)
dat = read.csv("Data/gpgp_02_1_1.csv", header = FALSE)
dim(Dat)
dim(dat)
View(dat)
write.csv(gpgp_data, "Data/gpgp_02_1_1.csv", row.names = T, col.names = F)
dat = read.csv("Data/gpgp_02_1_1.csv", header = FALSE)
View(dat)
write.csv(gpgp_data, "Data/gpgp_02_1_1.csv", row.names = F, col.names = T)
dat = read.csv("Data/gpgp_02_1_1.csv", header = FALSE)
write.csv(gpgp_data, "Data/gpgp_02_1_1.csv", row.names = F, col.names = NA)
dat = read.csv("Data/gpgp_02_1_1.csv", header = FALSE)
dat = read.csv("Data/gpgp_02_1_1.csv", header = T)
View(dat)
# Kriging with true parameters and estimated parameters with GPGP
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(GpGp)
library(maps)
dat = read.csv("Data/matern_02_1_5.csv", header = FALSE)
# Recover the original 3D dataframe
iters = 100
full_3D = array(0, dim = c(2000, 3, iters))
for (i in 1:iters) {
slice = dat[, i]
lon = slice[seq(1, length(slice), by = 3)]
lat = slice[seq(2, length(slice), by = 3)]
y = slice[seq(3, length(slice), by = 3)]
full_3D[,1,i] = lon
full_3D[,2,i] = lat
full_3D[,3,i] = y
}
full_3D.shape
dim(full_3D)
?krige.conv
?geoR::krige.conv
?geoR::krige.conv
# Train test split
train_row = sample(1:size, size * 0.8)
train = full[train_row, ]
test = full[-train_row, ]
rownames(train) = NULL
rownames(test) = NULL
s = as.matrix(train[, 1:2])
s0 = as.matrix(test[, 1:2])
X = rep(1, dim(train)[1])
X0 = rep(1, dim(test)[1])
pred <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(trend.d = ~X,  # Covariates at s
trend.l = ~X0, # Covariates at s0
cov.model="matern",
cov.pars=c(1, 0.2), # spatial var and range
kappa = 1
nugget=0.01))
pred <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(trend.d = ~X,  # Covariates at s
trend.l = ~X0, # Covariates at s0
cov.model="matern",
cov.pars=c(1, 0.2), # spatial var and range
kappa = 1,
nugget=0.01))
library(geoR)
pred <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(trend.d = ~X,  # Covariates at s
trend.l = ~X0, # Covariates at s0
cov.model="matern",
cov.pars=c(1, 0.2), # spatial var and range
kappa = 1,
nugget=0.01))
df <- data.frame(long=full[,1],lat=full[,2],Y=full[,3])
ggplot(df, aes(long, lat)) +
geom_point(aes(colour = Y)) +
scale_colour_gradientn(colours = viridis(10))
s
X
pred <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(cov.model="matern",
cov.pars=c(1, 0.2), # spatial var and range
kappa = 1,
nugget=0.01))
pred
mse = mean((yhat - test[,3])^2)
mse
yhat = pred$predict
mse = mean((yhat - test[,3])^2)
mse
size
# Use GPGP to estimate spatial cov
fit <- fit_model(train[,3], s, rep(1, size * 0.8), "matern_isotropic",  m_seq = c(10, 30))
params = fit$covparms
params
params = fit$covparms
vvv = params[1]
range = params[2]
smooth = params[3]
nugget = params[4]
pred_est <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(cov.model="matern",
cov.pars=c(vvv, range), # spatial var and range
kappa = smooth,
nugget=vvv * nugget))
yhat_est = pred_est$predict
mse_est = mean((yhat_est - test[,3])^2)
mse_est
mse
Ns = c(400, 600, 800, 1000, 1500)
MSE = rep(0, 6)
MSE_est = rep(0, 6)
for (n in NS) {
print(n)
}
Ns = c(400, 600, 800, 1000, 1500)
MSE = rep(0, 6)
MSE_est = rep(0, 6)
for (n in Ns) {
print(n)
}
dim(full_3D)
n = 400
i = 1
full = full_3D[1:n,,i]
dim(full)
full
# Kriging with true parameters and estimated parameters with GPGP
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(GpGp)
library(maps)
library(geoR)
dat = read.csv("Data/matern_02_1_5.csv", header = FALSE)
# Recover the original 3D dataframe
iters = 100
full_3D = array(0, dim = c(2000, 3, iters))
for (i in 1:iters) {
slice = dat[, i]
lon = slice[seq(1, length(slice), by = 3)]
lat = slice[seq(2, length(slice), by = 3)]
y = slice[seq(3, length(slice), by = 3)]
full_3D[,1,i] = lon
full_3D[,2,i] = lat
full_3D[,3,i] = y
}
Ns = c(400, 600, 800, 1000, 1500)
MSE = rep(0, 6)
MSE_est = rep(0, 6)
Ns = c(400, 600, 800, 1000, 1500)
MSE = rep(0, 6)
MSE_est = rep(0, 6)
X = rep(1, dim(train)[1])
X0 = rep(1, dim(test)[1])
# Recover the original 3D dataframe
iters = 100
full_3D = array(0, dim = c(2000, 3, iters))
for (i in 1:iters) {
slice = dat[, i]
lon = slice[seq(1, length(slice), by = 3)]
lat = slice[seq(2, length(slice), by = 3)]
y = slice[seq(3, length(slice), by = 3)]
full_3D[,1,i] = lon
full_3D[,2,i] = lat
full_3D[,3,i] = y
}
dat = read.csv("Data/matern_02_1_5.csv", header = FALSE)
# Recover the original 3D dataframe
iters = 100
full_3D = array(0, dim = c(2000, 3, iters))
for (i in 1:iters) {
slice = dat[, i]
lon = slice[seq(1, length(slice), by = 3)]
lat = slice[seq(2, length(slice), by = 3)]
y = slice[seq(3, length(slice), by = 3)]
full_3D[,1,i] = lon
full_3D[,2,i] = lat
full_3D[,3,i] = y
}
Ns = c(400, 600, 800, 1000, 1500)
MSE = rep(0, 6)
MSE_est = rep(0, 6)
for (j in 1:6) {
n = Ns[j]
for (i in 1:1) {
full = full_3D[1:n,,i]
# Train test split
train_row = sample(1:n, n * 0.8)
train = full[train_row, ]
test = full[-train_row, ]
rownames(train) = NULL
rownames(test) = NULL
X = rep(1, dim(train)[1])
X0 = rep(1, dim(test)[1])
s = as.matrix(train[, 1:2])
s0 = as.matrix(test[, 1:2])
pred <- krige.conv(data=train[,3],coords=s,
locations=s0,
krige=krige.control(cov.model="matern",
cov.pars=c(1, 0.2), # spatial var and range
kappa = 1,
nugget=0.01))
yhat = pred$predict
mse = mean((yhat - test[,3])^2)
# Use GPGP to estimate spatial cov
fit <- fit_model(train[,3], s, rep(1, n * 0.8), "matern_isotropic",  m_seq = c(10, 30))
params = fit$covparms
vvv = params[1]
range = params[2]
smooth = params[3]
nugget = params[4]
pred_est <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(cov.model="matern",
cov.pars=c(vvv, range), # spatial var and range
kappa = smooth,
nugget=vvv * nugget))
yhat_est = pred_est$predict
mse_est = mean((yhat_est - test[,3])^2)
MSE[j] = MSE[j] + mse
MSE_est[j] = MSE_est[j] + mse_est
}
}
MSE
MSE_est
n
j
MSE
MSE_est
vvv
range
smooth
nugget
# Kriging with true parameters and estimated parameters with GPGP
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(GpGp)
library(maps)
library(geoR)
dat = read.csv("Data/matern_02_1_5.csv", header = FALSE)
# Recover the original 3D dataframe
iters = 100
full_3D = array(0, dim = c(2000, 3, iters))
for (i in 1:iters) {
slice = dat[, i]
lon = slice[seq(1, length(slice), by = 3)]
lat = slice[seq(2, length(slice), by = 3)]
y = slice[seq(3, length(slice), by = 3)]
full_3D[,1,i] = lon
full_3D[,2,i] = lat
full_3D[,3,i] = y
}
Ns = c(400, 600, 800, 1000, 1500)
nnn = len(Ns)
length(Ns)
# Kriging with true parameters and estimated parameters with GPGP
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(GpGp)
library(maps)
library(geoR)
dat = read.csv("Data/matern_02_1_5.csv", header = FALSE)
# Recover the original 3D dataframe
iters = 100
full_3D = array(0, dim = c(2000, 3, iters))
for (i in 1:iters) {
slice = dat[, i]
lon = slice[seq(1, length(slice), by = 3)]
lat = slice[seq(2, length(slice), by = 3)]
y = slice[seq(3, length(slice), by = 3)]
full_3D[,1,i] = lon
full_3D[,2,i] = lat
full_3D[,3,i] = y
}
Ns = c(400, 600, 800, 1000, 1500)
nnn = length(Ns)
MSE = rep(0, nnn)
MSE_est = rep(0, nnn)
for (j in 1:nnn) {
n = Ns[j]
for (i in 1:1) {
full = full_3D[1:n,,i]
# Train test split
train_row = sample(1:n, n * 0.8)
train = full[train_row, ]
test = full[-train_row, ]
rownames(train) = NULL
rownames(test) = NULL
X = rep(1, dim(train)[1])
X0 = rep(1, dim(test)[1])
s = as.matrix(train[, 1:2])
s0 = as.matrix(test[, 1:2])
pred <- krige.conv(data=train[,3],coords=s,
locations=s0,
krige=krige.control(cov.model="matern",
cov.pars=c(5, 0.2), # spatial var and range
kappa = 1,
nugget=5))
yhat = pred$predict
mse = mean((yhat - test[,3])^2)
# Use GPGP to estimate spatial cov
fit <- fit_model(train[,3], s, rep(1, n * 0.8), "matern_isotropic",  m_seq = c(10, 30))
params = fit$covparms
vvv = params[1]
range = params[2]
smooth = params[3]
nugget = params[4]
pred_est <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(cov.model="matern",
cov.pars=c(vvv, range), # spatial var and range
kappa = smooth,
nugget=vvv * nugget))
yhat_est = pred_est$predict
mse_est = mean((yhat_est - test[,3])^2)
MSE[j] = MSE[j] + mse
MSE_est[j] = MSE_est[j] + mse_est
}
}
MSE
MSE_est
vvv
range
smooth
#################################################################
#################################################################
#################################################################
#################################################################
# Generate data from GpGp and try GpGp
#locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
iters = 100
N = 2000
gpgp_data = array(0, dim = c(N * 3, iters))
length <- 1
for (i in 1:iters) {
slice = rep(0, N*3)
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(5, 0.2, 1, 1), "matern_isotropic",  locs, 100)
lon = locs[,1]
lat = locs[,2]
slice[seq(1, length(slice), by = 3)] = lon
slice[seq(2, length(slice), by = 3)] = lat
slice[seq(3, length(slice), by = 3)] = y
gpgp_data[, i] = slice
}
full = cbind(lon, lat, y)
df <- data.frame(long=full[,1],lat=full[,2],Y=full[,3])
ggplot(df, aes(long, lat)) +
geom_point(aes(colour = Y)) +
scale_colour_gradientn(colours = viridis(10))
var(y)
write.csv(gpgp_data, "Data/gpgp_02_1_5.csv", row.names = F, col.names = NA)
# Kriging with true parameters and estimated parameters with GPGP
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(GpGp)
library(maps)
library(geoR)
dat = read.csv("Data/matern_02_1_5.csv", header = FALSE)
# Recover the original 3D dataframe
iters = 100
full_3D = array(0, dim = c(2000, 3, iters))
for (i in 1:iters) {
slice = dat[, i]
lon = slice[seq(1, length(slice), by = 3)]
lat = slice[seq(2, length(slice), by = 3)]
y = slice[seq(3, length(slice), by = 3)]
full_3D[,1,i] = lon
full_3D[,2,i] = lat
full_3D[,3,i] = y
}
Ns = c(400, 600, 800, 1000, 1500)
nnn = length(Ns)
MSE = rep(0, nnn)
MSE_est = rep(0, nnn)
for (j in 1:nnn) {
n = Ns[j]
for (i in 1:30) {
full = full_3D[1:n,,i]
# Train test split
train_row = sample(1:n, n * 0.8)
train = full[train_row, ]
test = full[-train_row, ]
rownames(train) = NULL
rownames(test) = NULL
X = rep(1, dim(train)[1])
X0 = rep(1, dim(test)[1])
s = as.matrix(train[, 1:2])
s0 = as.matrix(test[, 1:2])
pred <- krige.conv(data=train[,3],coords=s,
locations=s0,
krige=krige.control(cov.model="matern",
cov.pars=c(5, 0.2), # spatial var and range
kappa = 1,
nugget=5))
yhat = pred$predict
mse = mean((yhat - test[,3])^2)
# Use GPGP to estimate spatial cov
fit <- fit_model(train[,3], s, rep(1, n * 0.8), "matern_isotropic",  m_seq = c(10, 30))
params = fit$covparms
vvv = params[1]
range = params[2]
smooth = params[3]
nugget = params[4]
pred_est <- krige.conv(data=train[,3],coords=s, # Describe training data
locations=s0,    # Describe prediction sites
krige=krige.control(cov.model="matern",
cov.pars=c(vvv, range), # spatial var and range
kappa = smooth,
nugget=vvv * nugget))
yhat_est = pred_est$predict
mse_est = mean((yhat_est - test[,3])^2)
MSE[j] = MSE[j] + mse
MSE_est[j] = MSE_est[j] + mse_est
}
}
MSE
MSE = MSE / 30
MSE_est = MSE_est / 30
MSE
MSE_est
