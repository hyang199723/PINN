X.shape
dim(X)
ux
uy
2.5*(ux[2]-ux[1])
u   <- expand.grid(ux,uy)
u
dim(u)
d   <- rdist(s,u)/theta # could use sparse matrix operations
theta <- 2.5*(ux[2]-ux[1])
d   <- rdist(s,u)/theta
d
dim(d)
u
dim(u)
ux
uy
rsample(1:6, 2)
?rsample(1:6, 2)
?sample
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
out = rep(0, 1e5)
for (i in 1:1e5) {
out[i] = sum(sample(1:6, 2, replace = T))
}
out
hist(out)
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
sum(sample(1:6, 2, replace = T))
t.test2(m1, 0.1476, s1, 0.0082, n1, n2)
t.test2 <- function(m1,m2,s1,s2,n1,n2,m0=0,equal.variance=FALSE)
{
if( equal.variance==FALSE )
{
se <- sqrt( (s1^2/n1) + (s2^2/n2) )
# welch-satterthwaite df
df <- ( (s1^2/n1 + s2^2/n2)^2 )/( (s1^2/n1)^2/(n1-1) + (s2^2/n2)^2/(n2-1) )
} else
{
# pooled standard deviation, scaled by the sample sizes
se <- sqrt( (1/n1 + 1/n2) * ((n1-1)*s1^2 + (n2-1)*s2^2)/(n1+n2-2) )
df <- n1+n2-2
}
t <- (m1-m2-m0)/se
dat <- c(m1-m2, se, t, 2*pt(-abs(t),df))
names(dat) <- c("Difference of means", "Std Error", "t", "p-value")
return(dat)
}
m1 = 0.1569
s1 = 0.0113
n1 = n2 = 100
t.test2(m1, 0.1476, s1, 0.0082, n1, n2)
m1 = 0.5238
s1 = 0.0689
n1 = n2 = 100
t.test2(m1, 0.3521, s1, 0.113, n1, n2)
m1 = 0.5238
s1 = 0.0689
n1 = n2 = 100
t.test2(m1, 0.4295, s1, 0.0593, n1, n2)
m1 = 0.1569
s1 = 0.0113
n1 = n2 = 100
t.test2(m1, 0.1507, s1, 0.0077, n1, n2)
t.test2(m1, 0.1552, s1, 0.0077, n1, n2)
m1 = 0.3307
s1 = 0.0202
n1 = n2 = 100
t.test2(m1, 0.3279, s1, 0.0215, n1, n2)
t.test2(m1, 0.2843, s1, 0.0209, n1, n2)
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 2
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 2
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 2
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 2
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 2
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 2
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 10
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 13
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 13
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 13
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 13
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 13
a3 = 3
a4 = 4
a5 = 5
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 13
a3 = 3
a4 = 4
a5 = 15
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 13
a3 = 3
a4 = 4
a5 = 15
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
w = 1; x = -2; y = 3; z = 4
a1 = 1
a2 = 5
a3 = 3
a4 = 4
a5 = 15
a6 = 6
a7 = 7
a8 = 8
g = rep(rev(c(w,x,y,z)), 2)
v = c(a1,a2,a3,a4,a5,a6,a7,a8)
r = unsplit(lapply(split(v, g), max), c(w,y,x,z))
r
library(combinat)
install.packages("combinat")
library(combinat)
permn(1:24)
a = 1:24
a
permn(a)
sample(1:24, 24)
sample(a)
sample(1:21,24)
sample(1:21)
sample(1:24, 24)
#################################################################
#################################################################
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(GpGp)
locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
y <- fast_Gp_sim(c(4,0.2,0.5,0), "matern_isotropic",  locs, 30 )
fields::image.plot( matrix(y,50,50) )
length <- 1
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
N = 1000
length <- 1
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(4,0.2,0.5,0), "matern_isotropic",  locs, 30 )
fields::image.plot( matrix(y,50,50) )
matrix(runif(N * 2, 0, length), ncol = 2)
locs
y <- fast_Gp_sim(c(4,0.2,0.5,0), "matern_isotropic",  locs, 30 )
y
fields::image.plot( matrix(y,500,500) )
fields::image.plot( matrix(y,50,50) )
33*33
#################################################################
#################################################################
#################################################################
#################################################################
# Generate data from GpGp and try GpGp
#locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
N = 1089
length <- 1
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(4,0.2,0.5,0), "matern_isotropic",  locs, 30 )
fields::image.plot( matrix(y,33,33) )
y
# GPGP
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(GpGp)
gen_matern <- function(N, rho, spatial_var, noise_var, nu) {
set.seed(123)
length <- 1
coords <- matrix(runif(N * 2, 0, length), ncol = 2)
# Creating design matrix X
X <- cbind(rep(1, N), coords)
# Exponential Correlation
distance <- as.matrix(dist(coords))
corr <- Matern(distance, nu = nu, rho = rho)
# Cholesky decomposition and generate correlated data
L <- chol(spatial_var * corr)
z <- rnorm(N)
Y <- L %*% z + rnorm(N, sd = sqrt(noise_var))
return(list(X = X, Y = Y))
}
# Matern function definition
Matern <- function(distance, nu, rho) {
kappa <- sqrt(8 * nu) / rho
corr <- 2 ^ (1 - nu) / gamma(nu) * (kappa * distance) ^ nu * besselK(kappa * distance, nu)
corr[distance == 0] <- 1
return(corr)
}
#MSE = rep(0, iters)
N = 1000
P = 2
noise_var = 0.1
rho = 0.2
nu = 1
kappa = (8 * nu)**(0.5) / rho
spatial_var = 1
out = gen_matern(N, rho, spatial_var, noise_var, nu)
X = out$X
Y = out$Y
full = data.frame(cbind(X[, 2:3], Y))
colnames(full) <- c("Lon", "Lat", "y")
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
rownames(train) = NULL
rownames(test) = NULL
train_loc = as.matrix(train[, 1:2])
test_loc = as.matrix(test[, 1:2])
train_x = cbind(rep(1, 800), train[, 1:2])
test_x = cbind(rep(1, 200), test[, 1:2])
fit <- fit_model(train$y, train_loc, train_x, "matern_isotropic")
yhat = predictions(fit, test_loc, test_x)
mse = mean((yhat - test$y)^2)
mse
N = 1089
length <- 1
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(4,0.2,0.5,0), "matern15_isotropic",  locs, 30 )
# Matern isotropic
fields::image.plot( matrix(y,33,33) )
full = data.frame(cbind(locs, y))
full
full = data.frame(cbind(locs, y))
colnames(full) <- c("Lon", "Lat", "y")
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
fit <- fit_model(train$y, train_loc, train_x, "matern15_isotropic")
yhat = predictions(fit, test_loc, test_x)
mse = mean((yhat - test$y)^2)
test$y
#################################################################
#################################################################
#################################################################
#################################################################
# Generate data from GpGp and try GpGp
#locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
N = 1000
length <- 1
#################################################################
#################################################################
#################################################################
#################################################################
# Generate data from GpGp and try GpGp
#locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
N = 1000
length <- 1
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(1, 0.2, 0.1), "matern15_isotropic",  locs )
full = data.frame(cbind(locs, y))
colnames(full) <- c("Lon", "Lat", "y")
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
fit <- fit_model(train$y, train_loc, train_x, "matern15_isotropic")
yhat = predictions(fit, test_loc, test_x)
mse = mean((yhat - test$y)^2)
mse
#################################################################
#################################################################
#################################################################
#################################################################
# Generate data from GpGp and try GpGp
#locs <- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
N = 1000
length <- 1
locs <- matrix(runif(N * 2, 0, length), ncol = 2)
y <- fast_Gp_sim(c(1, 0.2, 1, 0.1), "matern_isotropic",  locs )
full = data.frame(cbind(locs, y))
colnames(full) <- c("Lon", "Lat", "y")
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
fit <- fit_model(train$y, train_loc, train_x, "matern_isotropic")
yhat = predictions(fit, test_loc, test_x)
mse = mean((yhat - test$y)^2)
mse
write.csv(full, "gpgp_matern.csv")
