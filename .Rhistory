# Creating design matrix X
X <- cbind(rep(1, N), coords)
# Exponential Correlation
distance <- as.matrix(dist(coords))
corr <- Matern(distance, nu = nu, rho = rho)
# Cholesky decomposition and generate correlated data
L <- chol(spatial_var * corr)
z <- rnorm(N)
Y <- L %*% z + rnorm(N, sd = sqrt(noise_var))
return(list(X = X, Y = Y))
}
# Matern function definition
Matern <- function(distance, nu, rho) {
kappa <- sqrt(2 * nu) / rho
corr <- 2 ^ (1 - nu) / gamma(nu) * (kappa * distance) ^ nu * besselK(kappa * distance, nu)
corr[distance == 0] <- 1
return(corr)
}
distance = 0.1
nu = 1
rho = 0.3
Matern(distance, nu, rho)
besselK(1, 1)
setwd("/Users/hongjianyang/PINN/")
gen_matern <- function(N, rho, spatial_var, noise_var, nu) {
set.seed(123)
length <- 1
coords <- matrix(runif(N * 2, 0, length), ncol = 2)
# Creating design matrix X
X <- cbind(rep(1, N), coords)
# Exponential Correlation
distance <- as.matrix(dist(coords))
corr <- Matern(distance, nu = nu, rho = rho)
# Cholesky decomposition and generate correlated data
L <- chol(spatial_var * corr)
z <- rnorm(N)
Y <- L %*% z + rnorm(N, sd = sqrt(noise_var))
return(list(X = X, Y = Y))
}
# Matern function definition
Matern <- function(distance, nu, rho) {
kappa <- sqrt(8 * nu) / rho
corr <- 2 ^ (1 - nu) / gamma(nu) * (kappa * distance) ^ nu * besselK(kappa * distance, nu)
corr[distance == 0] <- 1
return(corr)
}
# Matern simulation
N = 1000
P = 2
noise_var = 0.1
rho = 0.2
nu = 1
kappa = (8 * nu)**(0.5) / rho
spatial_var = 1
out = gen_matern(N, rho, spatial_var, noise_var, nu)
X = out$X
Y = out$Y
X
full = data.frame(cbind(X[, 2:3], Y))
full
library(ggplot2)
colnames(full) <- c("Lon", "Lat", "Y")
colnames(full) <- c("Lon", "Lat", "Y")
ggplot(full, aes(x = Lon, y = Lat, color = as.factor(Y))) +
geom_point() +
theme_minimal() +
labs(title = "Training data")
g <- ggplot(full, aes(x = Lon, y = Lat, color = as.factor(Y))) +
geom_point() +
theme_minimal() +
labs(title = "Training data")
g
g <- ggplot(full, aes(x = Lon, y = Lat, color = Y)) +
geom_point() +
theme_minimal() +
labs(title = "Training data")
g
var(full$Y)
g <- ggplot(full, aes(x = Lon, y = Lat, color = Y)) +
geom_point() +
theme_minimal() +
labs(title = "Training data") +
scale_color_gradient(low = "blue", high = "red")
g
g <- ggplot(full, aes(x = Lon, y = Lat, color = Y)) +
geom_point() +
theme_minimal() +
labs(title = "Training data") +
scale_color_gradient(low = "black", high = "yellow")
g
# Fitting using INLA package
library(INLA)
library(fields)
library(viridis)
g <- ggplot(full, aes(x = Lon, y = Lat, color = Y)) +
geom_point() +
theme_minimal() +
labs(title = "Training data") +
scale_color_viridis(c = 1, option = "D")
g <- ggplot(full, aes(x = Lon, y = Lat, color = Y)) +
geom_point() +
theme_minimal() +
labs(title = "Training data") +
scale_color_viridis(option = "D")
g
# Fitting using INLA package
library(INLA)
library(fields)
# The "s" is a scalar that change the domain size.
# So after multiplying by 3, the distance matrix is multiply by 3
s <- 3
# Locations of a few points.
pts <- cbind(c(0.1, 0.9, 1.5, 2, 2.3, 2, 1),
c(1, 1, 0, 0, 1.2, 1.9, 2)) * s
n <- nrow(pts)
# max.edge: The largest allowed triangle edge length.
mesh <- inla.mesh.2d(pts, max.edge = s * 0.5,
offset = s / 4, cutoff = s / 2)
mesh1 <- inla.mesh.2d(pts, max.edge = s * 5,
offset = 8, cutoff = s / 2)
par(mfrow=c(1,2))
plot(mesh);points(pts,col="blue",pch=19)
plot(mesh1);points(pts,col="blue",pch=19)
# offset: Extension distance, allow triangulation to extend further than observation sites.
mesh <- inla.mesh.2d(pts, max.edge = s * 1.5, offset = s/5)
mesh1 <- inla.mesh.2d(pts, max.edge = s * 1.5, offset = s*5)
par(mfrow=c(1,2))
plot(mesh); points(pts,col="blue",pch=19)
plot(mesh1); points(pts,col="blue",pch=19)
# Finally
mesh <- inla.mesh.2d(pts, max.edge = s * 1.5,offset = s*1.5)
plot(mesh); points(pts, col="blue")
# Number of vertices
m <- mesh$n
m
# Load data
data(BCEF, package = "spNNGP")
library(spNNGP)
# Load data
data(BCEF, package = "spNNGP")
forest <- BCEF
dim(forest)
head(forest)
rm(BCEF)
# Take two smaller subsamples
set.seed(2)
forest.train <- forest[sample(1:nrow(forest),1e2),]
forest.test <- forest[sample(1:nrow(forest),1e2),]
rm(forest)
# INLA
loc <- cbind(forest.train$x, forest.train$y)
colnames(loc)
loc
mesh <- inla.mesh.create(loc=loc,
extend=list(offset=-0.5), # if offset is, negative. An extension proportional to the site region is created
refine=list(min.angle=30))
par(mar = c(0, 0, 0, 0))
plot(mesh, asp = 1, main = "")
points(loc, pch=19,cex=0.4,col="blue")
par(mar = c(0, 0, 0, 0))
plot(mesh, asp = 1, main = "")
points(loc, pch=19,cex=0.4,col="blue")
forest.spde <- inla.spde2.matern(mesh = mesh, alpha = 2) # specify matern covariance function
A.forest <- inla.spde.make.A(mesh = mesh, loc = loc) # create projection matrix
s.index <- inla.spde.make.index(name = "spatial.field",
n.spde = forest.spde$n.spde) # index corresponding to data sites
forest.stack <- inla.stack(data  = list(FCH = forest.train$FCH),
A = list(A.forest, 1),
effects = list(c(s.index, list(Intercept = 1)),
list(PTC = forest.train$PTC)),
tag = "forest.data")
# Make prediction at the grid.
# For the sake of time, take a smaller subset for prediction.
load("BCEF_PTC.RData")
forest.stack
# Specify the form of the mean trend
form <- FCH ~ -1 + Intercept  + PTC + f(spatial.field, model = spde)
# Join stack training and testing
join.stack1 <- inla.stack(forest.stack, forest.stack.test)
# Specify the form of the mean trend
form <- FCH ~ -1 + Intercept  + PTC + f(spatial.field, model = spde)
# Fit SPDE model here
m1 <- inla(form, data = inla.stack.data(join.stack1, spde = forest.spde),
family = "gaussian",
control.predictor = list(A = inla.stack.A(join.stack1), compute = TRUE),
control.compute = list(cpo = TRUE, dic = TRUE))
forest.stack.test
train_row = sample(1:N, 800)
test_row = set(1:N) - train_row
test_row = 1:N - train_row
train_row
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
dim(train)
dim(test)
train[, 0:1]
train[, 0:2]
mesh <- inla.mesh.2d(loc = train[, 0:2])  # Define the mesh
formula <- y ~ 1 + f(train[, 0:2], model = spde, mesh = mesh)  # Replace 'y' and 'location' with your variables
fit <- inla(formula, data = train_data, family = "gaussian")
formula
fit <- inla(formula, data = train, family = "gaussian")
setwd("/Users/hongjianyang/PINN/")
library(ggplot2)
library(viridis)
library(spNNGP)
gen_matern <- function(N, rho, spatial_var, noise_var, nu) {
set.seed(123)
length <- 1
coords <- matrix(runif(N * 2, 0, length), ncol = 2)
# Creating design matrix X
X <- cbind(rep(1, N), coords)
# Exponential Correlation
distance <- as.matrix(dist(coords))
corr <- Matern(distance, nu = nu, rho = rho)
# Cholesky decomposition and generate correlated data
L <- chol(spatial_var * corr)
z <- rnorm(N)
Y <- L %*% z + rnorm(N, sd = sqrt(noise_var))
return(list(X = X, Y = Y))
}
# Matern function definition
Matern <- function(distance, nu, rho) {
kappa <- sqrt(8 * nu) / rho
corr <- 2 ^ (1 - nu) / gamma(nu) * (kappa * distance) ^ nu * besselK(kappa * distance, nu)
corr[distance == 0] <- 1
return(corr)
}
# Matern simulation
N = 1000
P = 2
noise_var = 0.1
rho = 0.2
nu = 1
kappa = (8 * nu)**(0.5) / rho
spatial_var = 1
out = gen_matern(N, rho, spatial_var, noise_var, nu)
X = out$X
Y = out$Y
full = data.frame(cbind(X[, 2:3], Y))
colnames(full) <- c("Lon", "Lat", "y")
g <- ggplot(full, aes(x = Lon, y = Lat, color = Y)) +
geom_point() +
theme_minimal() +
labs(title = "Training data") +
scale_color_viridis(option = "D")
g
# Fitting using INLA package
library(INLA)
library(fields)
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
mesh <- inla.mesh.2d(loc = train[, 0:2])  # Define the mesh
formula <- y ~ 1 + f(train[, 0:2], model = spde, mesh = mesh)  # Replace 'y' and 'location' with your variables
fit <- inla(formula, data = train, family = "gaussian")
spatial.field
mesh <- inla.mesh.2d(loc = train[, 0:2])  # Define the mesh
spde_model <- inla.spde2.pcmatern(mesh,
prior.sigma = c(1, 0.1),
prior.range = c(5, 1)) # Adjust priors as needed
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
fit <- inla(formula, data = train, family = "gaussian")
mesh <- inla.mesh.2d(loc = train[, 0:2], max.edge = c(0.1, 0.2))  # Define the mesh
mesh
plot(mesh)
s = 1
mesh <- inla.mesh.2d(loc = train[, 0:2], max.edge = s * 1.5, offset = s*5)  # Define the mesh
plot(mesh)
mesh <- inla.mesh.2d(loc = train[, 0:2], max.edge = s * 1.5, offset = s*2)  # Define the mesh
plot(mesh)
train[, 0:2]
mesh <- inla.mesh.2d(loc = train[, 0:2], max.edge = s * 1.1, offset = s*2)  # Define the mesh
plot(mesh)
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
fit <- inla(formula, data = train, family = "gaussian")
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
s = 1
mesh <- inla.mesh.2d(loc = train[, 0:2], max.edge = s * 1.1, offset = s*2)  # Define the mesh
plot(mesh)
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ 1 + f(train[, 0:2], model = spde_model)
fit <- inla(formula, data = train, family = "gaussian")
loc
type(loc)
train_loc = data.frame(train[, 0:2])
test_loc = data.frame(test[, 0:2])
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
s = 1
train_loc = data.frame(train[, 0:2])
test_loc = data.frame(test[, 0:2])
mesh <- inla.mesh.2d(loc = train_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
plot(mesh)
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ 1 + f(train_loc, model = spde_model)
fit <- inla(formula, data = train, family = "gaussian")
train_loc
train_loc = matrix(train[, 0:2])
test_loc = matrix(test[, 0:2])
train_loc
train[, 0:2]
train_loc = as.matrix(train[, 0:2])
train_loc
test_loc = as.matrix(test[, 0:2])
test_loc
train_loc = as.matrix(train[, 0:2])
test_loc = as.matrix(test[, 0:2])
mesh <- inla.mesh.2d(loc = train_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
plot(mesh)
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ 1 + f(train_loc, model = spde_model)
fit <- inla(formula, data = train, family = "gaussian")
rownames(train_loc) = NULL
train_loc
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
s = 1
rownames(train) = NULL
rownames(test)
train_loc = as.matrix(train[, 0:2])
test_loc = as.matrix(test[, 0:2])
train_row = sample(1:N, 800)
train = full[train_row, ]
test = full[-train_row, ]
s = 1
rownames(train) = NULL
rownames(test) = NULL
train_loc = as.matrix(train[, 0:2])
test_loc = as.matrix(test[, 0:2])
train_loc
test_loc = as.matrix(test[, 0:2])
mesh <- inla.mesh.2d(loc = train_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
plot(mesh)
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ 1 + f(train_loc, model = spde_model)
fit <- inla(formula, data = train, family = "gaussian")
train_loc
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ 1 + Lon + Lat f(train_loc, model = spde_model)
fit <- inla(formula, data = train, family = "gaussian")
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ 1 + Lon + Lat + f(train_loc, model = spde_model)
fit <- inla(formula, data = train, family = "gaussian")
train
colnames(train)
forest.stack
head(forest.train)
train
colnames(train)
# INLA
mesh_train <- inla.mesh.2d(loc = train_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
A_train <- inla.spde.make.A(mesh = mesh_train, loc = train_loc) # create projection matrix
# INLA
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
s.index <- inla.spde.make.index(name = "spatial.field",
n.spde = spde_model$n.spde) # index corresponding to data sites
spde_model$n.spde
mesh_train <- inla.mesh.2d(loc = train_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
A_train <- inla.spde.make.A(mesh = mesh_train, loc = train_loc) # create projection matrix
s.index
stack_train <- inla.stack(data  = list(y = train$y),
A = list(A_train, 1),
effects = list(c(s.index, list(Intercept = 1)),
list(predictor = train_loc)),
tag = "matern.data")
train_loc
# INLA
spde_model <- inla.spde2.matern(mesh = mesh, alpha = 2)
s.index <- inla.spde.make.index(name = "spatial.field",
n.spde = spde_model$n.spde) # index corresponding to data sites
mesh_train <- inla.mesh.2d(loc = train_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
A_train <- inla.spde.make.A(mesh = mesh_train, loc = train_loc) # create projection matrix
#A_test <- inla.spde.make.A(mesh = mesh_test, loc = test_loc) # create projection matrix
stack_train <- inla.stack(data  = list(y = train$y),
A = list(A_train, 1),
effects = list(c(s.index, list(Intercept = 1)),
list(predictor = train_loc)),
tag = "matern.data")
#plot(mesh)
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ -1 + Intercept + Lon + Lat + f(train_loc, model = spde_model)
fit <- inla(formula, data = inla.stack.data(stack_train), family = "gaussian",
control.predictor = list(A = inla.stack.A(stack_train), compute = TRUE))
#A_test <- inla.spde.make.A(mesh = mesh_test, loc = test_loc) # create projection matrix
stack_train <- inla.stack(data  = list(y = train$y),
A = list(A_train, 1),
effects = list(c(s.index, list(Intercept = 1)),
list(Lon = train$Lon,
Lat = train$Lat)),
tag = "matern.data")
#plot(mesh)
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ -1 + Intercept + Lon + Lat + f(train_loc, model = spde_model)
fit <- inla(formula, data = inla.stack.data(stack_train), family = "gaussian",
control.predictor = list(A = inla.stack.A(stack_train), compute = TRUE))
train_loc
#plot(mesh)
#formula <- y ~ 1 + f(train[, 0:2], model = spde_model, mesh = mesh)  # Replace 'y' and 'location' with your variables
formula <- y ~ -1 + Intercept + Lon + Lat + f(spatial.field, model = spde_model)
fit <- inla(formula, data = inla.stack.data(stack_train), family = "gaussian",
control.predictor = list(A = inla.stack.A(stack_train), compute = TRUE))
summary(fit)
A_test <- inla.spde.make.A(mesh = mesh_test, loc = test_loc) # create projection matrix
mesh_test <- inla.mesh.2d(loc = test_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
A_train <- inla.spde.make.A(mesh = mesh_train, loc = train_loc) # create projection matrix
A_test <- inla.spde.make.A(mesh = mesh_test, loc = test_loc) # create projection matrix
# Prediction
ef.prd = list(c(s.index, list(Intercept = 1)),
list(Lon = test$Lon,
Lat = test$Lat))
stack_test <- inla.stack(data = list(y = NA),
A = list(A_test, 1), tag = "prd",
effects = ef.prd)
# Prediction
ef.prd = list(c(s.index, list(Intercept = 1)),
list(Lon = test$Lon,
Lat = test$Lat))
stack_test <- inla.stack(data = list(y = NA),
A = list(A_test, 1), tag = "prd",
effects = ef.prd)
A_test <- inla.spde.make.A(mesh = mesh_train, loc = test_loc) # create projection matrix
stack_test <- inla.stack(data = list(y = NA),
A = list(A_test, 1), tag = "prd",
effects = ef.prd)
join.stack <- inla.stack(forest.stack, stack_test)
fit <- inla(formula, data = inla.stack.data(join.stack), family = "gaussian",
control.predictor = list(A = inla.stack.A(join.stack), compute = TRUE))
# Get testing data
index.test <- inla.stack.index(join.stack, "test")$data
stack_test <- inla.stack(data = list(y = NA),
A = list(A_test, 1), tag = "test",
effects = ef.prd)
join.stack <- inla.stack(forest.stack, stack_test)
fit <- inla(formula, data = inla.stack.data(join.stack), family = "gaussian",
control.predictor = list(A = inla.stack.A(join.stack), compute = TRUE))
# Get testing data
index.test <- inla.stack.index(join.stack, "test")$data
index.test
# Get testing data
index.test <- inla.stack.index(join.stack, "test")$data
fit$summary.fitted.values[index.test, "mean"]
fit$summary.fitted.values[index.test, "sd"]
test
summary(fit)
fit <- inla(formula, data = inla.stack.data(stack_train), family = "gaussian",
control.predictor = list(A = inla.stack.A(stack_train), compute = TRUE))
fit
fit_1 <- inla(formula, data = inla.stack.data(stack_train), family = "gaussian",
control.predictor = list(A = inla.stack.A(stack_train), compute = TRUE))
summary(fit_1)
test$Lon
test$Lat
# Testing locations
nxy <- c(150, 100)
projgrid <- rspde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),
ylim = range(PRborder[,2]), dims = nxy)
projgrid <- spde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),
ylim = range(PRborder[,2]), dims = nxy)
projgrid <- inla.spde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),
ylim = range(PRborder[,2]), dims = nxy)
full
full[,1]
full[,0]
full[,1]
full[,2]
X
train_loc = as.matrix(train[, 1:2])
train_loc
full
# Testing locations
nxy <- c(150, 100)
projgrid <- inla.mesh.projector(mesh_train, xlim = range(full[, 1]),
ylim = range(full[,2]), dims = nxy)
projgrid$proj$A
projgrid$proj
xy.in <- inout(projgrid$lattice$loc, cbind(full[, 1], full[, 2]))
# Testing locations
library(gridExtra)
xy.in <- inout(projgrid$lattice$loc, cbind(PRbord
asdq
library(ggplot2)
library(lattice)
library(INLA)
library(splancs)
library(fields)
nxy <- c(150, 100)
xy.in <- inout(projgrid$lattice$loc, cbind(full[, 1], full[, 2]))
projgrid <- inla.mesh.projector(mesh_train, xlim = range(full[, 1]),
ylim = range(full[,2]), dims = nxy)
xy.in
coord.prd <- projgrid$lattice$loc[xy.in, ]
coord.prd
mesh <- inla.mesh.2d(loc = train_loc, max.edge = s * 1.1, offset = s*2)  # Define the mesh
A_train <- inla.spde.make.A(mesh = mesh, loc = train_loc) # create projection matrix
A_test <- inla.spde.make.A(mesh = mesh, loc = test_loc) # create projection matrix
dim(A_train)
dim(A_test)
ef.prd = list(c(s.index, list(Intercept = 1)),
list(Lon = test$Lon,
Lat = test$Lat))
