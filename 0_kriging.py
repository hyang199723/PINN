# Get MSE using Kriging and Matern correlation# Generate from a matern correlation process# N: number of data points# rho: spatial correlation# vvv: varianceimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport numpy as npimport randomfrom scipy.special import gamma, kvimport mathfrom scipy.spatial import distance_matrixdef Matern_Cor(nu, rho, distance):    kappa = (8 * nu)**(0.5) / rho    const = 1 / (2**(nu - 1) * gamma(nu))    kd = kappa * distance    first_term = kd**nu    second_term = kv(nu, kd)    second_term[np.diag_indices_from(second_term)] = 0.    out = const * first_term * second_term    out[np.diag_indices_from(out)] = 1.0    return outdef gen_matern(N, rho, spatial_var, noise_var, nu):    n = N    random.seed(123)    length = 1    coords = np.random.uniform(0, length, (N, 2))    X = np.zeros((n, 3))    X[:, 0] = 1    X[:, 1:3] = coords    # Exponential Correlation    distance = distance_matrix(coords.reshape(-1, 2), coords.reshape(-1, 2))    corr = Matern_Cor(nu, rho, distance)    # Cholesky decomposition and generate correlated data    L = np.linalg.cholesky(spatial_var*corr)    z = np.random.normal(0, 1, n)    Y = np.dot(L, z) + np.random.normal(0, noise_var, n)    return X, Ydef Kriging(X_train, X_test, y_train, spatial_corr):    N = X_train.shape[0] + X_test.shape[0]    n2 = X_test.shape[0] # Test size    s_train = X_train    s_test = X_test    coords = np.concatenate((s_test, s_train))    distance = distance_matrix(coords.reshape(-1, 2), coords.reshape(-1, 2))    v_bar = np.var(y_train)    cov_bar = v_bar * np.exp(-distance / spatial_corr)    sigma11 = cov_bar[0:n2, 0:n2]    sigma12 = cov_bar[0:n2, n2:N]    sigma21 = np.transpose(sigma12)    sigma22 = cov_bar[n2:N, n2:N]    sigma22_inv = np.linalg.inv(sigma22)    sigma_bar = sigma11 - np.dot(np.dot(sigma12, sigma22_inv), sigma21)    mu_bar = np.dot(np.dot(sigma12, sigma22_inv), y_train)    zzz = np.random.normal(0, 1, n2)    L = np.linalg.cholesky(sigma_bar)    y_hat = mu_bar + np.dot(L, zzz)    return y_hat# Randomly split datadef random_split(X, Y):    n = X.shape[0]    rows = [i for i in range(0, n)]    train_size = math.floor(n * 0.8)    random.seed(123)    train_row = random.sample(range(n), train_size)    train_row.sort()    test_row = list(set(rows) - set(train_row))    X_train = X[train_row, :]    y_train = Y[train_row]    X_test = X[test_row, :]    y_test = Y[test_row]    return X_train, X_test, y_train, y_testNs = [400, 600, 1000, 1500, 1800, 2100, 2500]P = 2noise_var = 0.1rho = 0.2nu = 1kappa = (8 * nu)**(0.5) / rhospatial_var = 1iters = 100MSE = pd.DataFrame(data = 0.0, index = range(iters), columns = Ns)for idx, n in enumerate(Ns):    for i in range(iters):        X, Y = gen_matern(n, rho, spatial_var, noise_var, nu)        X = X[:, 1:3]        X_train, X_test, y_train, y_test = random_split(X, Y)        yhat = Kriging(X_train, X_test, y_train, 0.2)        mse = np.mean((yhat - y_test)**2)        MSE.iloc[i, idx] = mseMSE.to_csv("/Users/hongjianyang/Desktop/Kriging_matern.csv")        #%%mean = MSE.mean()std = MSE.std()plt.figure(figsize=(10, 6))plt.errorbar(x=mean.index, y=mean, yerr=std, fmt='o-', capsize=5, label="Kriging")plt.legend()